## 模块二：ES新特性与Typascript、JS性能优化

### 一、请说出下列的执行结果，并解释为什么。
```
var a = [];
for (var i = 0; i< 10; i++) {
	a[i] = function () {
		console.log(i)
	}
}
a[6]()

```
*答：执行结果是10，因为数组为每个元素都绑定了一个函数，函数内打印的值是i, 而i是var声明的变量，在当前的全局有效，当循环完成之后，i的值是10，所以无论执行数组内的哪一个元素，结果都是10* 

### 二、请说出下列的执行结果，并解释为什么。
```
var tmp = 123;
if (true) {
	console.log(tmp)
	let tmp
}
```
*答：执行结果是引用错误 ReferenceError，因为在if语句内打印变量tmp，会优先在局部也就是if语句内查找，但是在if语句内tmp是在打印之后且使用let声明的，let不会变量提升，所以会报错。*

### 三、结合ES6新语法，用最简单的方式找出数组中的最小。
```
var arr = [12, 34, 32, 89, 4];

```
```
let min = Math.min(...arr);
cosnole.log(min);  //4
```

### 四、请详细说明var，let，const三种声明变量的方式之间的具体差别。

* var声明的变量，在没有初始化的情况下可以变量提升，也就是在声明之前就可使用，并且var声明的变量的作用域是函数或全局；
* let声明的变量无论有没有初始化都不会变量提升，并且let声明的变量的作用域是代码块；
* const声明的是常量，相当于在let声明的基础上增加了「只读」属性，但是可以修改对象内的属性值，只是不可以修改内存指向

### 五、请说出下列代码的最终输出结果，并解释为什么。
```
var a = 10;
var obj = {
	a: 20,
	fn () {
		setTimeout(() => {
			console.log(this.a)
		})
	}
}

obj.fn();

```
*答：最后的执行结果是20，因为箭头函数不会改变this的指向，此时定时器内的回调函数的this指向fn所在的obj对象，所以，this.a是20*

### 六、简述symbol类型的用途。
*答：Symbol是一种新的原始数据类型，由Symbol函数生成一个独一无二的值，主要用于生成对象的属性，这样可以保证属性名不会冲突，并且私有。*

### 七、说说什么是浅拷贝，什么是深拷贝？
* 浅拷贝是创建一个新对象，这个对象有原始对象的属性值的一份精确拷贝。如果属性值是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址，所以，如果其中一个对象改变了这个地址，就会影响另一个对象。
* 深拷贝是将一个对象完整的拷贝一份出来，从堆内存中开辟一个新的区域存放新对象，且修改新对象不会影响原对象。

> 补充：浅拷贝与赋值的区别，浅拷贝是拷贝原始对象的第一层的属性，不包括对象里面的为引用类型的数据，赋值是直接拷贝的原始对象的内存地址，所以，如果修改原始对象的第一层的基本类型，浅拷贝得到的对象不受影响，但是赋值得到的就会跟着改变。


### 八、简述TypeScript与JavaScript之间的关系。
*答：TypeScript是一门基于JavaScript之上的编程语言，是JavaScript的超集，扩展了一套类型系统以及对于ECAMScript新特性的支持，TypeScript最终会被编译成原始的JavaScript*

### 九、请谈谈你所认为的TypeScript的优缺点。
* 优点
	* 有强大的类型系统的支持可以减少代码的出错概率
	* 支持ECAMScript的新特性提高开发效率
	* 而且在任何一种JavaScript运行环境都支持TypeScript
* 缺点
	* 学习成本高
	* 在项目初期会因为定义大量的类型声明而增加开发成本

### 十、描述引用计数的工作原理和优缺点
* 工作原理： 设置引用数，引用关系发生改变时修改引用数字，当引用数字为0时立即回收。
* 优点
	* 发现垃圾时立即回收
	* 最大限度减少程序暂停
* 缺点
	* 无法回收循环引用的对象
	* 时间开销大
	
### 十一、描述标记整理算法的工作流程
> 分为标记阶段和清除阶段

* 标记阶段：遍历所有对象，找到活动对象（可达对象）进行标记
* 清除阶段
	* 整理操作，移动对象位置得到连续空间
	* 遍历所有对象，清除没有标记的对象，抹去之前被标记对象的标记，便于下一次GC
	* 回收垃圾空间，交给空闲列表

### 十二、描述V8中新生代存储区垃圾回收的流程
*答：新生代内存去分为两个等大的空间，一个是使用空间是From，一个是空闲空间是To，被标记的活动对象存储于From空间，当From空间到达一定的上限时就会触发GC，然后用标记整理的方法对活动对象进行标记和整理（得到连续空间从而减少空间碎片化），之后把From内的活动对象拷贝至To空间（在此过程中会有符合条件的新生代晋升到老生代），再把From空间释放回收*

### 十三、描述增量标记算法在何时使用及工作原理
* 增量标记算法：将一整段的垃圾回收操作，拆分成多个小步，组合完成整个垃圾回收操作。这是因为在垃圾回收工作的时候，会阻塞JS程序执行，当我们需要优化垃圾回收的效率时，就可以使用增量标记算法。
* 工作原理：
	* 当垃圾回收工作时，需要遍历对象进行标记，此时不需要将所有对象进行标记，可以先将直接可达的对象进行标记，此时停下标记操作
	* 然后让JS程序执行一会，之后，再让 GC 机制去做二步的标记操作，去标记那些间接可达的对象
	* 重复以上两步，让程序执行和垃圾回收的标记操作交替执行，来达到优化效率和提升用户体验的目的
	* 直到标记操作完成之后，最后执行垃圾回收

	
	


